<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nuestra Historia</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            touch-action: none;
        }

        #canvas1 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- UI General --- */
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #progress-container {
            display: flex;
            gap: 5px;
            padding: 10px 10px;
            width: 100%;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .progress-segment {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: white;
            transition: width 0.1s linear;
        }

        .nav-controls {
            position: absolute;
            top: 50%;
            width: 100%;
            transform: translateY(-50%);
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
            opacity: 0;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 40px;
            font-size: 1.2rem;
            background: transparent;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 50px;
            cursor: pointer;
            z-index: 20;
            text-transform: uppercase;
            letter-spacing: 2px;
            pointer-events: auto;
            transition: all 0.5s;
        }

        #start-btn:hover {
            background: #fff;
            color: #d60000;
            box-shadow: 0 0 30px rgba(255, 0, 50, 0.8);
        }

        #reveal-btn {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 50px;
            font-size: 1.5rem;
            background: #ff3366;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: all 0.5s;
            box-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
            font-weight: bold;
        }

        #reveal-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #reveal-btn:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Estilos del Contador Final */
        #countdown {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: white;
            z-index: 20;
            opacity: 0;
            transition: opacity 1s;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 30px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #countdown.visible {
            opacity: 1;
        }

        .timer-label {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            color: #ff99aa;
        }

        .timer {
            font-size: 1.5rem;
            font-weight: bold;
            font-family: monospace;
            letter-spacing: 1px;
        }

        @media (max-width: 600px) {
            #start-btn {
                font-size: 1rem;
                padding: 12px 30px;
            }

            #reveal-btn {
                font-size: 1.2rem;
                padding: 15px 30px;
                width: 90%;
            }

            #countdown {
                bottom: 15%;
                width: 90%;
            }

            .timer {
                font-size: 1.2rem;
            }
        }
    </style>
</head>

<body>

    <canvas id="canvas1"></canvas>

    <div class="ui-container">
        <div id="progress-container"></div>
        <div class="nav-controls" id="nav-controls">
            <button class="nav-btn" id="prev-btn">❮</button>
            <button class="nav-btn" id="next-btn">❯</button>
        </div>
    </div>

    <button id="start-btn">Comenzar</button>
    <button id="reveal-btn">¿Quieres saber qué sigue?</button>

    <!-- Contenedor del Contador -->
    <div id="countdown">
        <div class="timer-label">Próximo San Valentín</div>
        <div class="timer" id="timer-val">00d 00h 00m 00s</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const startBtn = document.getElementById('start-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const progressContainer = document.getElementById('progress-container');
        const navControls = document.getElementById('nav-controls');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const countdownEl = document.getElementById('countdown');
        const timerVal = document.getElementById('timer-val');

        let particles = [];
        let fontSize = Math.min(canvas.width * 0.12, 80);

        let currentState = 'intro';

        let passcode = [0, 0, 0, 0, 0, 0];

        // CORRECCIÓN: Usar constructor con (Año, Mes-1, Día) para evitar problemas de zona horaria
        // Meses van de 0 (Enero) a 11 (Diciembre). Julio es 6.
        const startDate = new Date(2023, 6, 23); // 23 de Julio de 2023

        // Extraer partes de la fecha para el código y el texto
        const targetDay = startDate.getDate();
        const targetMonth = startDate.getMonth() + 1; // 0-11 a 1-12
        const targetYear = startDate.getFullYear() % 100; // últimos 2 dígitos

        // Generar código correcto dinámicamente [D, D, M, M, A, A]
        const d1 = Math.floor(targetDay / 10);
        const d2 = targetDay % 10;
        const m1 = Math.floor(targetMonth / 10);
        const m2 = targetMonth % 10;
        const y1 = Math.floor(targetYear / 10);
        const y2 = targetYear % 10;

        const correctCode = [d1, d2, m1, m2, y1, y2];

        let clickZones = [];
        let currentCorrectDigits = 0;

        // Cálculos de fecha para la historia
        const today = new Date();
        const diffTime = Math.abs(today - startDate);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        const monthsNames = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"];
        const formattedDateStr = `${startDate.getDate()} de ${monthsNames[startDate.getMonth()]}\ndel ${startDate.getFullYear()}`;

        // Textos actualizados con fecha dinámica
        const storySequence = [
            { text: "Dicen que los días\nimportantes no siempre\nvienen anunciados...", time: 6000 },
            { text: `Pero el ${formattedDateStr}\nfue la excepción.`, time: 6000 },
            { text: "Fue el momento exacto\nen el que el mundo\ndejó de ser un\nlugar ordinario...", time: 6000, effect: 'world_grey' },
            { text: "Para llenarse de colores\nque solo tú\nsabes pintar.", time: 6000, effect: 'world_color' },
            { text: "Ese día no solo aceptamos\ncaminar juntos;\ndecidimos que\ncualquier camino...", time: 6000 },
            { text: "Si es contigo,\nvale la pena.", time: 5000 },
            { text: `Hoy, ${diffDays} días después...`, time: 5000 },
            { text: "Sigo eligiendo esa\nmisma fecha como el\ninicio de mi mejor historia.", time: 6000 }
        ];

        let storyIndex = -1;
        let storyTimer = null;

        const mouse = { x: null, y: null, radius: 30 };
        window.addEventListener('mousemove', (e) => { mouse.x = e.x; mouse.y = e.y; });

        // Manejo de Clics (PC)
        window.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            const x = e.clientX;
            const y = e.clientY;
            if (currentState === 'lock') checkLockClick(x, y);
            else if (currentState === 'question') checkQuestionClick(x, y);
        });

        // Manejo de Touch (Móvil)
        window.addEventListener('touchstart', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            if (e.cancelable) e.preventDefault();
            const x = e.touches[0].clientX;
            const y = e.touches[0].clientY;
            mouse.x = x; mouse.y = y;
            if (currentState === 'lock') checkLockClick(x, y);
            if (currentState === 'question') checkQuestionClick(x, y);
        }, { passive: false });

        startBtn.addEventListener('click', () => {
            startBtn.classList.add('hidden');
            initLockState();
        });

        revealBtn.addEventListener('click', () => {
            revealBtn.classList.remove('visible');
            showFinalQuestion();
        });

        prevBtn.addEventListener('click', () => {
            if (storyIndex > 0) {
                clearTimeout(storyTimer);
                storyIndex--;
                loadStoryScene(storyIndex);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (storyIndex < storySequence.length - 1) {
                clearTimeout(storyTimer);
                storyIndex++;
                loadStoryScene(storyIndex);
            } else {
                clearTimeout(storyTimer);
                endStoryMode();
            }
        });

        function wrapText(context, text, maxWidth) {
            const words = text.replace(/\n/g, " \n ").split(' ');
            let lines = [];
            let currentLine = words[0];
            for (let i = 1; i < words.length; i++) {
                let word = words[i];
                if (word === "\n") { lines.push(currentLine); currentLine = ""; continue; }
                let width = context.measureText(currentLine + " " + word).width;
                if (width < maxWidth) { currentLine += (currentLine === "" ? "" : " ") + word; }
                else { lines.push(currentLine); currentLine = word; }
            }
            if (currentLine.trim() !== "") lines.push(currentLine);
            return lines;
        }

        function getTextCoordinates(text, x, y, size, useMaxWidth = true) {
            const isMobile = canvas.width < 600;
            const actualSize = isMobile ? size * 0.8 : size;
            ctx.font = `900 ${actualSize}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let lines = [];
            if (useMaxWidth) {
                const maxWidth = canvas.width * 0.9;
                lines = wrapText(ctx, text, maxWidth);
            } else { lines = text.split('\n'); }

            const lineHeight = actualSize * 1.3;
            const startY = y - ((lines.length - 1) * lineHeight) / 2;

            lines.forEach((line, i) => { ctx.fillText(line, x, startY + (i * lineHeight)); });

            const gap = isMobile ? 2 : 2;
            const points = [];
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            for (let py = 0; py < canvas.height; py += gap) {
                for (let px = 0; px < canvas.width; px += gap) {
                    if (data[(py * canvas.width + px) * 4 + 3] > 128) points.push({ x: px, y: py, z: 0 });
                }
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return points;
        }

        function getLockCoordinates() {
            let points = [];
            clickZones = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const isMobile = canvas.width < 600;
            const spacing = isMobile ? canvas.width * 0.13 : 80;
            const startX = -(spacing * 2.5);
            const digitSize = isMobile ? 35 : 60;
            const arrowSize = digitSize * 0.6;
            const verticalGap = digitSize * 1.4;

            const titlePoints = getTextCoordinates("FECHA ESPECIAL", centerX, centerY - (verticalGap * 2.5), isMobile ? 24 : 30, false);

            points = points.concat(titlePoints);

            passcode.forEach((digit, index) => {
                let xPos = centerX + startX + (index * spacing);
                if (index >= 2) xPos += spacing * 0.5;
                if (index >= 4) xPos += spacing * 0.5;

                const digitPoints = getTextCoordinates(digit.toString(), xPos, centerY, digitSize, false);
                points = points.concat(digitPoints);

                const upArrowPoints = getTextCoordinates("▲", xPos, centerY - verticalGap, arrowSize, false);
                points = points.concat(upArrowPoints);
                clickZones.push({ x: xPos - arrowSize, y: centerY - verticalGap - arrowSize, w: arrowSize * 2, h: arrowSize * 2, index: index, action: 'up' });

                const downArrowPoints = getTextCoordinates("▼", xPos, centerY + verticalGap, arrowSize, false);
                points = points.concat(downArrowPoints);
                clickZones.push({ x: xPos - arrowSize, y: centerY + verticalGap - arrowSize, w: arrowSize * 2, h: arrowSize * 2, index: index, action: 'down' });
            });
            return points;
        }

        function getHeartCoordinates(count) {
            const points = [];
            const scale = Math.min(canvas.width, canvas.height) / (canvas.width < 600 ? 35 : 25);
            for (let i = 0; i < count; i++) {
                let t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                let px = (x * scale) + canvas.width / 2;
                let py = (y * scale) + canvas.height / 2;
                let pz = Math.random() * 500 + 100;
                points.push({ x: px, y: py, z: pz, isBackgroundHeart: true });
            }
            return points;
        }

        function getSphereCoordinates(count, radius) {
            const points = [];
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                points.push({ x: x + canvas.width / 2, y: y + canvas.height / 2, z: z, isWorld: true });
            }
            return points;
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y; this.z = (Math.random() - 0.5) * 1000;
                this.targetX = x; this.targetY = y; this.targetZ = this.z;
                this.size = Math.random() * 3 + 2;
                this.colorHue = Math.random() * 40 + 330;
                this.colorSat = '80%'; this.colorLight = '50%';
            }
            update() {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dz = this.targetZ - this.z;
                this.x += dx * 0.12;
                this.y += dy * 0.12;
                this.z += dz * 0.12;

                if (this.isWorldParticle) {
                    const angle = 0.01; const cx = canvas.width / 2; const cz = 0;
                    const x = this.x - cx; const z = this.z - cz;
                    this.x = x * Math.cos(angle) - z * Math.sin(angle) + cx;
                    this.z = x * Math.sin(angle) + z * Math.cos(angle) + cz;
                }
            }
            draw() {
                const perspective = 800;
                const scale = perspective / (perspective + this.z);
                if (scale < 0.1) return;
                const screenX = (this.x - canvas.width / 2) * scale + canvas.width / 2;
                const screenY = (this.y - canvas.height / 2) * scale + canvas.height / 2;
                const s = this.size * scale;
                if (s < 0.5) return;

                ctx.fillStyle = `hsla(${this.colorHue}, ${this.colorSat}, ${this.colorLight}, ${scale})`;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + s * 0.2);
                ctx.bezierCurveTo(screenX - s / 2, screenY - s / 2, screenX - s, screenY + s / 3, screenX, screenY + s);
                ctx.bezierCurveTo(screenX + s, screenY + s / 3, screenX + s / 2, screenY - s / 2, screenX, screenY + s * 0.2);
                ctx.fill();
            }
        }

        function initParticles(count) {
            particles = [];
            const isMobile = canvas.width < 600;
            const finalCount = isMobile ? 1200 : 2500;
            for (let i = 0; i < finalCount; i++) {
                particles.push(new Particle(Math.random() * canvas.width, Math.random() * canvas.height));
            }
        }

        function initLockState() {
            currentState = 'lock';
            updateBackgroundHeart(0);
        }

        function checkLockClick(x, y) {
            for (let z of clickZones) {
                if (x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h) {
                    changeDigit(z.index, z.action); return;
                }
            }
        }

        function changeDigit(index, action) {
            passcode[index] = action === 'up' ? (passcode[index] + 1) % 10 : (passcode[index] - 1 + 10) % 10;
            particles.forEach(p => { if (p.colorSat === '0%') p.z -= 50; });
            checkCode();
        }

        function updateBackgroundHeart(correctCount) {
            const lockTargets = getLockCoordinates();
            const spareParticles = particles.length - lockTargets.length;
            const heartParticleCount = Math.floor((correctCount / 6) * spareParticles * 0.9);
            let heartTargets = [];
            if (heartParticleCount > 0) heartTargets = getHeartCoordinates(heartParticleCount);
            const finalTargets = lockTargets.concat(heartTargets);
            assignTargets(finalTargets, false, { progressiveHeart: true });
        }

        function checkCode() {
            let newCorrectCount = 0;
            passcode.forEach((val, index) => { if (val === correctCode[index]) newCorrectCount++; });
            currentCorrectDigits = newCorrectCount;
            if (currentCorrectDigits === 6) {
                currentState = 'success';
                updateBackgroundHeart(6);
                setTimeout(() => {
                    particles.forEach(p => { if (p.colorSat === '0%') { p.targetZ -= 800; p.colorHue = 350; p.colorSat = '100%'; } });
                    setTimeout(initStoryMode, 1000);
                }, 1500);
            } else {
                updateBackgroundHeart(currentCorrectDigits);
            }
        }

        function initStoryMode() {
            currentState = 'story';
            progressContainer.innerHTML = '';
            storySequence.forEach((_, i) => {
                const seg = document.createElement('div');
                seg.className = 'progress-segment';
                const fill = document.createElement('div');
                fill.className = 'progress-fill';
                fill.id = `fill-${i}`;
                seg.appendChild(fill);
                progressContainer.appendChild(seg);
            });
            progressContainer.style.opacity = 1;
            navControls.style.opacity = 1;
            storyIndex = 0;
            loadStoryScene(0);
        }

        function loadStoryScene(index) {
            for (let i = 0; i < storySequence.length; i++) {
                const fill = document.getElementById(`fill-${i}`);
                if (i < index) fill.style.width = '100%';
                else if (i > index) fill.style.width = '0%';
                else fill.style.width = '0%';
            }

            const scene = storySequence[index];
            let targets = [];
            const isMobile = canvas.width < 600;
            const storyFontSize = isMobile ? 32 : 60;

            if (scene.effect === 'world_grey' || scene.effect === 'world_color') {
                const worldRadius = Math.min(canvas.width, canvas.height) / (isMobile ? 3 : 3.5);
                targets = getSphereCoordinates(isMobile ? 1200 : 2000, worldRadius);
                const textPoints = getTextCoordinates(scene.text, canvas.width / 2, canvas.height / 2, storyFontSize * 0.9, true);
                textPoints.forEach(p => p.z -= 300);
                targets = targets.concat(textPoints);
            } else {
                targets = getTextCoordinates(scene.text, canvas.width / 2, canvas.height / 2, storyFontSize, true);
            }

            const options = { effect: scene.effect };
            assignTargets(targets, false, options);

            const currentFill = document.getElementById(`fill-${index}`);
            currentFill.style.transition = `width ${scene.time}ms linear`;
            setTimeout(() => { currentFill.style.width = '100%'; }, 50);

            clearTimeout(storyTimer);
            storyTimer = setTimeout(() => {
                if (index < storySequence.length - 1) {
                    storyIndex++;
                    loadStoryScene(storyIndex);
                } else {
                    endStoryMode();
                }
            }, scene.time);
        }

        function endStoryMode() {
            currentState = 'pre_question';
            progressContainer.style.opacity = 0;
            navControls.style.opacity = 0;
            particles.forEach(p => {
                p.targetX = Math.random() * canvas.width;
                p.targetY = Math.random() * canvas.height;
            });
            setTimeout(() => { revealBtn.classList.add('visible'); }, 500);
        }

        function showFinalQuestion() {
            currentState = 'question';
            clickZones = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const isMobile = canvas.width < 600;

            let targets = getTextCoordinates("¿QUIERES SER\nMI SAN VALENTÍN?", centerX, centerY - 100, isMobile ? 35 : 60, true);

            const yesX = centerX - (isMobile ? 80 : 150);
            const btnY = centerY + 100;
            const yesPoints = getTextCoordinates("SÍ", yesX, btnY, 50, false);
            yesPoints.forEach(p => { p.isBtn = true; p.btnType = 'yes'; });
            targets = targets.concat(yesPoints);
            clickZones.push({ x: yesX - 60, y: btnY - 40, w: 120, h: 80, action: 'yes' });

            const noX = centerX + (isMobile ? 80 : 150);
            const noPoints = getTextCoordinates("NO", noX, btnY, 50, false);
            noPoints.forEach(p => { p.isBtn = true; p.btnType = 'no'; });
            targets = targets.concat(noPoints);
            clickZones.push({ x: noX - 60, y: btnY - 40, w: 120, h: 80, action: 'no' });

            const heartPoints = getHeartCoordinates(1500);
            targets = targets.concat(heartPoints);

            assignTargets(targets, false, { isQuestion: true });
        }

        function checkQuestionClick(x, y) {
            for (let z of clickZones) {
                if (x >= z.x && x <= z.x + z.w && y >= z.y && y <= z.y + z.h) {
                    if (z.action === 'yes') celebrate();
                    if (z.action === 'no') disperseParticles();
                }
            }
        }

        function disperseParticles() {
            particles.forEach(p => {
                p.vx = (Math.random() - 0.5) * 50;
                p.vy = (Math.random() - 0.5) * 50;
                p.targetX += p.vx * 10;
                p.targetY += p.vy * 10;
                p.colorSat = '0%';
            });
            setTimeout(showFinalQuestion, 2000);
        }

        function startCountdown() {
            countdownEl.classList.add('visible');
            const updateTimer = () => {
                const now = new Date();
                const currentYear = now.getFullYear();
                let valentine = new Date(currentYear, 1, 14); // Mes 1 es Febrero
                if (now > valentine) valentine = new Date(currentYear + 1, 1, 14);

                const diff = valentine - now;
                const d = Math.floor(diff / (1000 * 60 * 60 * 24));
                const h = Math.floor((diff / (1000 * 60 * 60)) % 24);
                const m = Math.floor((diff / 1000 / 60) % 60);
                const s = Math.floor((diff / 1000) % 60);

                timerVal.innerText = `${d}d ${h}h ${m}m ${s}s`;
            };
            setInterval(updateTimer, 1000);
            updateTimer();
        }

        function celebrate() {
            currentState = 'celebration';
            clickZones = [];
            particles.forEach(p => {
                p.targetX = Math.random() * canvas.width;
                p.targetY = Math.random() * canvas.height;
                p.targetZ = (Math.random() - 0.5) * 2000;
                p.colorHue = Math.random() * 360;
                p.colorSat = '100%'; p.colorLight = '60%';
            });

            setTimeout(() => {
                const finalTargets = getTextCoordinates("¡TE AMO! ❤️", canvas.width / 2, canvas.height / 2, 80);
                const heartBg = getHeartCoordinates(2000);
                assignTargets(finalTargets.concat(heartBg), true);
                // Iniciar contador
                startCountdown();
            }, 1000);
        }

        function assignTargets(targets, isFinalTheme, options = {}) {
            if (targets.length > particles.length) {
                const missing = targets.length - particles.length;
                for (let i = 0; i < missing; i++) particles.push(new Particle(canvas.width / 2, canvas.height / 2));
            }

            particles.forEach((p, i) => {
                p.isWorldParticle = false;
                if (i < targets.length) {
                    p.targetX = targets[i].x; p.targetY = targets[i].y; p.targetZ = targets[i].z || 0;

                    if (options.isQuestion) {
                        if (targets[i].isBtn) {
                            p.colorHue = targets[i].btnType === 'yes' ? 120 : 0;
                            p.colorSat = '100%'; p.colorLight = '60%';
                        } else if (targets[i].isBackgroundHeart) {
                            p.colorHue = 340; p.colorSat = '100%'; p.colorLight = '40%';
                        } else {
                            p.colorHue = 0; p.colorSat = '0%'; p.colorLight = '100%';
                        }
                    }
                    else if (isFinalTheme) {
                        p.colorHue = targets[i].isBackgroundHeart ? 340 : 360; p.colorSat = '100%'; p.colorLight = '60%';
                    }
                    else if (options.effect === 'world_grey') {
                        if (targets[i].isWorld) { p.isWorldParticle = true; p.colorHue = 0; p.colorSat = '0%'; p.colorLight = Math.random() * 50 + 20 + '%'; }
                        else { p.colorHue = 0; p.colorSat = '0%'; p.colorLight = '100%'; }
                    }
                    else if (options.effect === 'world_color') {
                        if (targets[i].isWorld) { p.isWorldParticle = true; p.colorHue = Math.random() * 360; p.colorSat = '80%'; p.colorLight = '60%'; }
                        else { p.colorHue = 0; p.colorSat = '0%'; p.colorLight = '100%'; }
                    }
                    else if (options.progressiveHeart) {
                        if (targets[i].isBackgroundHeart) { p.colorHue = 350; p.colorSat = '90%'; p.colorLight = '55%'; }
                        else { p.colorHue = 0; p.colorSat = '0%'; p.colorLight = '100%'; }
                    }
                    else {
                        p.colorHue = 0; p.colorSat = '0%'; p.colorLight = '100%';
                    }
                } else {
                    p.targetX = Math.random() * canvas.width; p.targetY = Math.random() * canvas.height; p.targetZ = (Math.random() - 0.5) * 2000;
                    p.colorHue = Math.random() * 40 + 330; p.colorSat = '80%'; p.colorLight = '35%';
                }
            });
        }

        function animate() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animate);
        }

        initParticles(2000);
        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            fontSize = Math.min(canvas.width * 0.12, 80);
            if (currentState === 'lock') updateBackgroundHeart(currentCorrectDigits);
        });

    </script>
</body>

</html>